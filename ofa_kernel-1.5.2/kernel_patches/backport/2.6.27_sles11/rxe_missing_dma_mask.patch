diff -r -N -u ofa_kernel-1.5.2.orig/drivers/infiniband/core/umem.c ofa_kernel-1.5.2/drivers/infiniband/core/umem.c
--- ofa_kernel-1.5.2.orig/drivers/infiniband/core/umem.c	2010-09-21 10:51:29.000000000 -0500
+++ ofa_kernel-1.5.2/drivers/infiniband/core/umem.c	2010-10-03 22:44:26.000000000 -0500
@@ -65,6 +65,39 @@
 	}
 }
 
+static int
+check_addr(char *name, struct device *hwdev, dma_addr_t bus, size_t size)
+{
+	if (hwdev && hwdev->dma_mask && bus + size > *hwdev->dma_mask) {
+		if (*hwdev->dma_mask >= DMA_32BIT_MASK)
+			printk(KERN_ERR
+			    "nommu_%s: overflow %Lx+%zu of device mask %Lx\n",
+				name, (long long)bus, size,
+				(long long)*hwdev->dma_mask);
+		return 0;
+	}
+	return 1;
+}
+
+static int my_map_sg(struct device *hwdev, struct scatterlist *sg,
+	       int nents, int direction)
+{
+	struct scatterlist *s;
+	int i;
+
+	WARN_ON(nents == 0 || sg[0].length == 0);
+
+	for_each_sg(sg, s, nents, i) {
+		BUG_ON(!sg_page(s));
+		s->dma_address = sg_phys(s);
+		if (hwdev && !check_addr("map_sg", hwdev, s->dma_address, s->length))
+			return 0;
+		s->dma_length = s->length;
+	}
+	flush_write_buffers();
+	return nents;
+}
+
 /**
  * ib_umem_get - Pin and DMA map userspace memory.
  * @context: userspace context to pin memory for
@@ -178,11 +211,10 @@
 				sg_set_page(&chunk->page_list[i], page_list[i + off], PAGE_SIZE, 0);
 			}
 
-			chunk->nmap = ib_dma_map_sg_attrs(context->device,
+			chunk->nmap = my_map_sg(context->device->dma_device,
 							  &chunk->page_list[0],
 							  chunk->nents,
-							  DMA_BIDIRECTIONAL,
-							  &attrs);
+							  DMA_BIDIRECTIONAL);
 			if (chunk->nmap <= 0) {
 				for (i = 0; i < chunk->nents; ++i)
 					put_page(sg_page(&chunk->page_list[i]));
