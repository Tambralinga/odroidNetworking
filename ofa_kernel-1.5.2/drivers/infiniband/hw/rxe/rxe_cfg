#!/usr/bin/perl

# * Copyright (c) 2009 Mellanox Technologies Ltd. All rights reserved.
# * Copyright (c) 2009 System Fabric Works, Inc. All rights reserved.
# *
# * This software is available to you under a choice of one of two
# * licenses.  You may choose to be licensed under the terms of the GNU
# * General Public License (GPL) Version 2, available from the file
# * COPYING in the main directory of this source tree, or the
# * OpenIB.org BSD license below:
# *
# *     Redistribution and use in source and binary forms, with or
# *     without modification, are permitted provided that the following
# *     conditions are met:
# *
# *	- Redistributions of source code must retain the above
# *	  copyright notice, this list of conditions and the following
# *	  disclaimer.
# *
# *	- Redistributions in binary form must reproduce the above
# *	  copyright notice, this list of conditions and the following
# *	  disclaimer in the documentation and/or other materials
# *	  provided with the distribution.
# *
# * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# * SOFTWARE.
#
use Getopt::Long;
use Switch;

$z = "2>/dev/null";

$help = 0;
$no_persist = 0;
$debug = 0;
$force = 0;
$linkonly = 0;
my $parms = "/sys/module/ib_rxe/parameters";
my $net_parms = "/sys/module/ib_rxe_net/parameters";

$modprobe_opt = "";
$modprobe_checked = "0";

GetOptions(
	   "-h"          => \$help,
	   "--help"      => \$help,
	   "-n"          => \$no_persist,
	   "-v:+"        => \$debug,
	   "-f"          => \$force,
	   "-l"          => \$linkonly,
	   "-p:s"        => \$proto_id,
	   "--proto:s"   => \$proto_id,
	   );

$arg1 = $ARGV[0];
$arg2 = $ARGV[1];
$arg3 = $ARGV[2];

$persistence_path = "/var/rxe";
$persistence_file = "${persistence_path}/rxe";
$num_persistent = 0;

$sys = "/sys/module/ib_rxe";
$net_sys = "/sys/module/ib_rxe_net";

if ($help) {
    printusage();
    exit;
}

# status is the default
if (!defined($ARGV[0]) || ($arg1 =~ /status/)) {
    do_status($arg2);
    exit;
}

# Stuff that does not require the ib_rxe module to be loaded
switch($arg1) {
    case "start"	{ rxe_bringup(); 	do_status(); 	exit; }#
    case "persistent"	{ system("cat $persistence_file"); 	exit; }
    case "rds"		{ do_rds(); 				exit; }
}

if (chk_module_status()) {
    exit;
}

# create persistence file if necessary
`mkdir -p $persistence_path $z`;
if (!(-e $persistence_file)) {
    `touch $persistence_file $z`;
}

# Get full context of the configuration
populate_persistence();
populate_status();
populate_ethinfo();

# Stuff that requires the ib_rxe module to be loaded
switch($arg1) {
    case "unload"	{ unload(); 			exit; }
    case "stop"		{ unload(); 			exit; }
    case "devinfo"	{ do_devinfo($arg2); 		exit; }
    case "debug"	{ do_debug($arg2);	 	exit; }
    case "crc"		{ do_crc($arg2); 		exit; }
    case "show"		{ do_show(); 			exit; }
    case "mtu"		{ do_mtu($arg2, $arg3); 	exit; }
    case "net_mtu"	{ set_net_mtu($arg2, $arg3); 	exit; }
    case "add"		{ rxe_add($arg2); 		exit; }
    case "remove"	{ rxe_remove($arg2); 		exit; }
    case "defaults"	{ do_defaults(); do_show();	exit; }
    case "read-tune"	{ do_read_tune(); do_show();	exit; }
    case "1g-tune"	{ do_1g_tune(); do_show();	exit; }
    case "nobwlimit"	{ do_zero(); 			exit; }
    case "help"		{ printusage();			exit; }
    case "fast"		{ do_fast();			exit; }
    case "slow"		{ do_slow();			exit; }
    case "show_fast"	{ do_show_fast();		exit; }
}

if (!defined($arg1) || !defined($arg2)) {
    printusage();
    exit;
}

exit;

#***************************************************************
# Nothing but subroutines below this line

sub populate_status {
    return if (!(-e "/sys/class/infiniband"));
    my @lines = `ls /sys/class/infiniband | grep rxe $z`;

    my $rxe_idx = 0;
    
    foreach my $this_rxe (@lines) {
	chomp($this_rxe);

	$this_eth = `cat /sys/class/infiniband/$this_rxe/parent $z`;
	
	chomp($this_eth);
	#print "$this_rxe $this_eth\n";
	if (($this_eth =~ /eth[0123456789]/)
	    && ($this_rxe =~ /rxe[0123456789]/)) {
	    
	    #print "index $index eth $this_eth rxe $this_rxe_name\n";
	    # hash ethername to rxename
	    $rxe_names{$this_eth} = $this_rxe;
	    $rxe_array[$rxe_idx] = $this_rxe;
	    $rxe_idx++;
	    
	    # hash rxename to ethername
	    $eth_names{$this_rxe} = $this_eth;
	}
    }
}

sub populate_persistence {
    my @lines = `cat $persistence_file $z`;
    my $line;
    $num_persistent = 0;
    
    print "populate_persistent\n" if ($debug);

    foreach $line (@lines) {
	chomp($line);
	$line =~ s/^\s+//g;  # strip leading white space
	if ($line =~ /eth[0123456789]/) {
	    my ($eth, $cruft) = split(/\s+/, $line, 2); # in case we add fields later
	    print "eth $eth" if ($debug);
	    if ($eth =~ /^eth[1234567890]/) {
		$persistence_array[$num_persistent] = $eth;
		$persistence_hash{$eth} = $num_persistent;
		$num_persistent ++;
		print "...good\n" if ($debug);
	    }
	    else {
		print "\n" if ($debug);
	    }
	}
	else {
	    print "unrecognized line: $line\n" if ($debug);
	}
    }
    print "------------------\n" if ($debug);
}

sub commit_persistent {
    open(PF, ">$persistence_file");
    
    for ($i=0; $i<$num_persistent; $i++) {
	my $eth = $persistence_array[$i];
	if ($eth =~ /eth[1234567890]/) {
	    print(PF "$persistence_array[$i]\n");
	}
    }
    close(PF);
}

sub delete_persistent {
    my $eth = $_[0];
    
    print "delete_persistent: eth $eth\n" if ($debug);

    if (defined($persistence_hash{$eth})) {
	$persistence_array[$persistence_hash{$eth}] = "";
    }
}

sub add_persistent {
    my $eth = $_[0];

    # Is this one already in the persistence list?
    if (!defined($persistence_hash{$eth})) {
	$persistence_array[$num_persistent] = $eth;
	$persistence_hash{$eth} = $num_persistent;
	$num_persistent++;
    }
}

sub get_devinfo {
    my $rxe = $_[0];

    my $cmd = "ibv_devinfo -d $rxe";
    return `$cmd $z`;
}

sub rxe_add {
    my $eth_name = $_[0];

    print "add $eth_name\n";

    if (!($eth_name =~ /eth[0123456789]/)) {
	print "eth_name ($eth_name) looks bogus\n";
	return;
    }
    if (!defined($rxe_names{$eth_name})) {
	system("echo '$eth_name' > $net_parms/add");
    }
    else {
	#print "$rxe_names{$eth_name} on $eth_name already\n";
    }
    if (!$no_persist) {
	add_persistent($eth_name);
	commit_persistent();
    }
}

sub rxe_remove {
    my $arg2 = $_[0];

    print "remove $arg2\n"  if ($debug > 0);

    if ($arg2 =~ /eth[0123456789]/) {
	$eth_name = $arg2;
	$rxe = $rxe_names{$eth_name};
    }
    elsif ($arg2 =~ /rxe[0123456789]/) {
	$rxe = $arg2;
	$eth_name = $eth_names{$rxe};
    }
    elsif ($arg2 eq "all") {
	$rxe = "all";
    }

    if (($rxe eq "all") || ($rxe =~ /^rxe[0123456789]/)) {
	$cmd = "echo '$rxe' > $net_parms/remove";
	#print "$cmd\n";
	system($cmd);
	if (!$no_persist) {
	    if ($rxe eq "all") {
		unlink($persistence_file);
	    }
	    elsif ($eth_name =~/eth[0123456789]/) {
		delete_persistent($eth_name);
		commit_persistent();
	    }
	    else {
		print "Warning: Unable to resolve ethname; "
		    . "instance may persist on restart\n";
	    }
	}
    }
    else {
	print "rxe instance $rxe not found\n";
    }
}

sub chk_proto_id_conf {
    my @lines = `cat /etc/infiniband/openib.conf | grep RXE_ETH_PROTO`;
    my $val = "";
    foreach $line (@lines) {
	chomp($line);
	if ($line =~ /RXE_ETH_PROTO_ID/) {
	    #if it's in there more than once, this will return the FIRST one
	    my ($param, $val) = split(/=/, $line);
	    $val =~ s/^\s+//g;  # strip leading white space
	    $val =~ s/\s+$//g;  # strip trailing white space
	    print "rxe_cfg: $line from openib.conf\n";
	    return $val;
	}
    }
    return;
}

sub rxe_bringup {
    my $proto_str = "";
    my $warnings = 0;

    if (defined($proto_id)) {
	if (-e $net_sys) {
	    print "ERROR: CANNOT SET PROTO ID - rxe_net already loaded\n";
	    exit(-1);
	}
	$proto_str = "eth_proto_id=$proto_id";
    }
    else {
	# check openib.conf for protocol id 
	$proto_id = chk_proto_id_conf();
	if (defined($proto_id)) {
	    if (-e $net_sys) {
		print "ERROR: CANNOT SET PROTO ID - rxe_net already loaded\n";
		exit(-1);
	    }
	    $proto_str = "eth_proto_id=$proto_id";	    
	}
    }

    if (-e $net_sys) {
	print "Warning: ib_rxe_net already loaded\n";
	$warnings++;
    }
    if (-e $sys) {
	print "Warning: ib_rxe already loaded\n";
	if ($warnings > 0) {
	    print "Nothing to do\n";
	    exit(0);
	}
    }

    system("mkdir -p /var/rxe");
    system("touch $persistence_file");

    modprobe("ib_core");
    modprobe("ib_uverbs");
    modprobe("ib_rxe");
    modprobe("ib_rxe_net", "$proto_str");

    populate_persistence();

    foreach $eth (@persistence_array) {
	print "Try to add ($eth)\n" if ($debug > 0);
	rxe_add($eth);
    }

    populate_status();

    foreach $rxe (@rxe_array) {
	my $stat = get_devinfo($rxe);
	if ($stat =~ "PORT_DOWN") {
	    my $cmd = "ifconfig $eth_names{$rxe} up";
	    #print "$cmd\n";
	    system($cmd);
	}
    }
}

sub get_mlx4_list {
    my $num = 0;
    return if (!(-e "/sys/class/infiniband"));
    my @mlx4_list = `ls /sys/class/infiniband | grep mlx4_ $z`;
    foreach my $mlx4 (@mlx4_list) {
	chomp($mlx4);
	#print "get_mlx4_list: $mlx4\n";
	chdir("/sys/class/infiniband/$mlx4/ports");
	my @ports = `ls $z`;
	foreach my $port (@ports) {
	    chomp($port);
	    #print "port: $port\n";
	    my $link_layer = `cat $port/link_layer $z`;
	    chomp($link_layer);
	    if ($link_layer =~ "Ethernet") {
		$mlx4_ether[$num] = $mlx4;
		$mlx4_port[$num] = $port;
		#print "num $num: $mlx4 : $port\n";
		$num++;
	    }
	}
    }
}

sub populate_ethinfo {
    my $num_eth = 0;
    $mlx_num = 0;
    get_mlx4_list();
    @eth_list = `ls /sys/class/net | grep eth $z`;
    foreach my $eth (@eth_list) {
	chomp($eth);
	$eth_list[$num_eth++] = $eth;
	# figure out which driver for each ethernet interface
	my @lines = `ethtool -i $eth $z`;
	foreach my $line (@lines) {
	    chomp($line);
	    chomp($fields[0]);
	    my @fields = split(/\s+/, $line);
	    if ($fields[0] =~ /driver:/) {
		my $drv = $fields[1];
		#print "$eth\t$fields[1]\n";
		$eth_driver{$eth} = $drv;
		if ($drv =~ /mlx4_en/) {
		    $np = "$mlx4_ether[$mlx_num],$mlx4_port[$mlx_num]";
		    $mlx_name{$eth} = $mlx4_ether[$mlx_num];
		    $mlx_port{$eth} = $mlx4_port[$mlx_num];
		    $eth_names{$np} = $eth;
		    $mlx_num++;
		}
	    }
	    
	}
	# get link status
	@lines = `ethtool $eth $z`;
	foreach $line (@lines) {
	    chomp($line);
	    my @fields = split(/:/, $line);
	    $fields[1] =~ s/^\s+//g;
	    if ($fields[0] =~ "Link detected") {
		$link_state{$eth} = $fields[1];
	    }
	    elsif ($line =~ "10000baseT") {
		$link_speed{$eth} = "10GigE";
	    }
	}
	@lines = `ifconfig $eth $z`;
	$ipv4_addr{$eth} = "            ";
	foreach $line (@lines) {
	    # get IP address
	    if ($line =~ /inet addr/) {
		$line =~ s/^\s+inet addr://g;
		@fields = split(/\s+/, $line);
		$ipv4_addr{$eth} = $fields[0];
	    }
	    # get ethernet mtu
	    if ($line =~ /MTU:/) {
		$line =~ s/^.*MTU://g;
		@fields = split(/\s+/, $line);
		$eth_mtu{$eth} = $fields[0];
	    }
	}
    }
    # get rxe mtu
    foreach my $rxe (@rxe_array) {
	my @lines  = `ibv_devinfo -d $rxe 2>/dev/null $z`;
	#print "get mtu for $rxe\n";
	
	foreach my $line (@lines) {
	    if ($line =~ "active_mtu") {
		$line =~ s/^\s+active_mtu:\s+//g;
		chomp($line);
		#print "\tline: $line\n";
		$rxe_mtu{$rxe} = $line;
		#print "\tmunged: $line\n";
	    }
	}
    }
}

sub is_integer {
    defined $_[0] && $_[0] =~ /^[+-]?\d+$/;
}

sub validate_mtu {
    my $mtu = $_[0];
    if ((!is_integer($mtu)) || 
	!(($mtu == 512)     || ($mtu == 1024)
	  || ($mtu == 2048) || ($mtu == 4096))) {
	print "Invalid mtu ($mtu)\n";
	print "Legal values are 512, 1024, 2048, 4096\n";
	exit;
    }
}

sub ethernet_mtu {
    my $mtu = $_[0];
    validate_mtu($mtu);
    $mtu += 80;  # Pad for RoCEE mtu
    return $mtu;
}

sub set_rxe_mtu {
    my $rxe = $_[0];
    my $mtu = $_[1];

    $cmd = "echo '$rxe $mtu' > /sys/module/ib_rxe_net/parameters/mtu";
    print "set_rxe_mtu: $cmd\n";
    system($cmd);
}

sub set_eth_mtu {
    my $eth = $_[0];
    my $rxe_mtu = $_[1];

    #print "set_eth_mtu($eth, $rxe_mtu)\n";

    # we only set it if it's not already big enough
    
    # round up so rxe mtu will fit
    my $eth_mtu = ethernet_mtu($rxe_mtu);  
    
    if ($eth_mtu > $eth_mtu{$eth}) {
	# gotta up the ethernet mtu
	my $cmd = "ifconfig $eth mtu $eth_mtu";
	print "$cmd\n";
	system($cmd);
    }
    else {
	print "set_eth_mtu: $eth: $eth_mtu <= $eth_mtu{$eth}\n";
    }
}

sub set_mtu {
    my $dev = $_[0];
    my $mtu_size = $_[1];

    print "set_mtu: ($dev, $mtu_size)\n";

    validate_mtu($mtu_size);

    set_rxe_mtu($dev, $mtu_size) 	if (!($dev =~ "mlx4"));

    if ($dev =~ "mlx4_") {
	# we only look at ethernet MTU if force is set
	system("ifdown $eth_names{$dev}") if ($dev =~ "mlx4_");
	set_eth_mtu($eth_names{$dev}, $mtu_size);
	system("ifup $eth_names{$dev}")   if ($dev =~ "mlx4_");
    }
    elsif ($force > 0) {
	if ($dev =~ "rxe") {
	    set_eth_mtu($eth_names{$dev}, $mtu_size);
	}
	elsif ($dev =~ "all") {
	    foreach my $rxe (@rxe_array) {
		set_eth_mtu($eth_names{$rxe}, $mtu_size);
	    }
	}
    }
}

sub set_net_mtu {
    my $rxe = $_[0];
    my $mtu_size = $_[1];

    print "net_mtu: ($rxe, $mtu_size)\n";

    if ($rxe =~ "mlx4_") {
	# we only look at ethernet MTU if force is set
	system("ifdown $eth_names{$rxe}") if ($rxe =~ "mlx4_");
	set_eth_mtu($eth_names{$rxe}, $mtu_size);
	system("ifup $eth_names{$rxe}")   if ($rxe =~ "mlx4_");
    }
    else {
	if ($rxe =~ "rxe") {
	    my $cmd = "ifconfig $eth_names{$rxe} mtu $mtu_size";
	    print "$cmd\n";
	    system($cmd);
	}
	elsif ($rxe =~ "all") {
	    foreach my $rxe (@rxe_array) {
		my $cmd = "ifconfig $eth_names{$rxe} mtu $mtu_size";
		print "$cmd\n";
		system($cmd);
	    }
	}
    }
}

sub unload {
    foreach my $rxe (@rxe_array) {
	$cmd = "echo '$rxe' > $net_parms/remove";
	system($cmd);
    }
    $cmd = "rmmod ib_rxe_net";
    system($cmd);
    $cmd = "rmmod ib_rxe";
    system($cmd);
}

sub do_devinfo() {
    foreach my $rxe_name (@rxe_array) {
	my $cmd = "ibv_devinfo $ARGV[3] $ARGV[2] -d $rxe_name ";
	print "$cmd\n"; 
	system("$cmd $z");
    }
}


sub do_debug {
    my $arg2 = $_[0];
    my $debugfile = "$parms/debug";
    chomp($arg2);

    #print "debug $arg2\n";
    #system("echo 'debug $arg2' > $proc");

    if (!(-e "$debugfile")) {
	print "Error: debug is compiled out of this rxe driver\n";
	return;
    }

    switch ($arg2) {
	case "on"   { 	system("echo '31' > $debugfile"); }
	case "off"  { 	system("echo '0'  > $debugfile"); }
	case "0"    { 	system("echo '0'  > $debugfile"); }
	case ""     { }
	elsif ($arg2 ge "0" && $arg2 le "31") {
	    system("echo '$arg2' > $debugfile");
	}
	else {
	    print "unrecognized debug cmd ($arg2)\n";
	}
    }

    my $current = `cat $debugfile $z`;
    chomp($current);
    if ($current > 0) {
	print "Debug is ON ($current)\n";
    }
    elsif ($current == 0) {
	print "Debug is OFF\n";
    }
    else {
	print "Unrecognized debug value\n";
    }
}

sub do_crc {
    my $arg2 = $_[0];

    chomp($arg2);

    switch ($arg2) {
	case "enable"  { system("echo '0' > $parms/crc_disable"); }
	case "disable" { system("echo '1' > $parms/crc_disable"); }
    }
    my $state = `cat $parms/crc_disable`;
    chomp($state);
    switch($state) {
	case "1" { print "CRC is disabled\n"; }
	case "0" { print "CRC is enabled\n"; }
    }
}

sub do_rds {
    modprobe("ib_ucm");
    modprobe("rdma_cm");
    modprobe("rdma_ucm");
    modprobe("rds_rdma");
}

sub do_show {
    if (-e "/sys/module/ib_rxe") {
	print "rxe parameters:\n";
	print "  nsec_per_packet = "
	    . `cat $parms/nsec_per_packet $z`;
	print "  nsec_per_kbyte = " 
	    . `cat $parms/nsec_per_kbyte $z`;
	print "  max_skb_per_qp = "
	    . `cat $parms/max_skb_per_qp $z`;
	print "  max_req_comp_gap = "
	    . `cat $parms/max_req_comp_gap $z`;
	
	print "  max_pkt_per_ack = "
	    . `cat $parms/max_pkt_per_ack $z`;
    }
    else {
	print "Error: ib_rxe module apparently not loaded\n";
    }
}

sub do_defaults {
    if (-e "/sys/module/ib_rxe") {
	`echo   0 > $parms/nsec_per_packet $z`;
	`echo   0 > $parms/nsec_per_kbyte $z`;
	`echo 800 > $parms/max_skb_per_qp $z`;
	`echo 128 > $parms/max_req_comp_gap $z`;
	`echo  64 > $parms/max_pkt_per_ack $z`;
    }
    else {
	print "Error: ib_rxe module apparently not loaded\n";
    }
}

sub do_read_tune {
    do_defaults();
    if (-e "/sys/module/ib_rxe") {
	`echo   20  > $parms/nsec_per_packet $z`;
	`echo   700 > $parms/nsec_per_kbyte $z`;
    }
    else {
	print "Error: ib_rxe module apparently not loaded\n";
    }
}

sub do_1g_tune {
    do_defaults();
    if (-e "/sys/module/ib_rxe") {
	`echo   200  > $parms/nsec_per_packet $z`;
	`echo   7000 > $parms/nsec_per_kbyte $z`;
    }
    else {
	print "Error: ib_rxe module apparently not loaded\n";
    }
}

sub do_zero {
    `echo 0 > $parms/nsec_per_packet $z`;
    `echo 0 > $parms/nsec_per_kbyte $z`;
}

sub do_mtu {
    my $arg2 = $_[0];
    my $arg3 = $_[1];

    my $mtu_size;
    print "mtu $arg2 $arg3\n";
    if (!defined($arg2)) {
	print "bogus mtu command\n";
	return;
    }

    if (($arg2 =~ "rxe[0123456789]") || ($arg2 =~ "mlx4_")) {
	set_mtu($arg2, $arg3);
	do_status($arg2);
    }
    else {
	$mtu_size = $arg2;
	set_mtu("all", $mtu_size);
	do_status("rxe");
    }
}

sub show_proto_id {
    if (-e $net_sys) {
	my $proto_id = `cat $net_parms/eth_proto_id`;
	chomp($proto_id);
	printf("rxe eth_proto_id: 0x%x", $proto_id);
	print " *** Non-standard ***" if ($proto_id ne 35093);
	print "\n";
    }
}

sub chk_module_status {
    my $rxe_loaded = 1;
    my $rxe_net_loaded = 1;
    if (!(-e $net_sys)) {
	$rxe_net_loaded = 0;
    }

    if (!(-e $sys)) {
	$rxe_loaded = 0;
    }
    if ($rxe_loaded && $rxe_net_loaded) {
	show_proto_id();
	return 0;
    }
    elsif (!$rxe_loaded && !$rxe_net_loaded) {
	print "rxe modules not loaded\n";
	return 1;
    }
    elsif ($rxe_loaded) {
	print "ib_rxe is loaded, but ib_rxe_net is NOT loaded\n";
	return 1;
    }
    else {
	print "Configuration does not make sense\n";
	return 1;
    }
}

sub max {
    my $a = $_[0];
    my $b = $_[1];
    return $a if ($a > $b);
    return $b;
}

sub status_print {
    # one pass to size the columns
    foreach my $line (@_) {
	@fields = split(/\s+/, $line);
	$i = 0;
	foreach my $field (@fields) {
	    if (!defined($flen[$i])) {
		$flen[$i] = length($field);
	    }
	    else {
		$flen[$i] = max($flen[$i], length($field));
	    }
	    $i++;
	}
	$num_fields = $i;
    }
    # one pass to print
    foreach my $line (@_) {
	@fields = split(/\s+/, $line);
	for ($i=0; $i<$num_fields; $i++) {
	    my $pad = $flen[$i] - length($fields[$i]) + 2;
	    if ($fields[$i] ne "n/a") {
		print "$fields[$i]";
	    }
	    else {
		print "   ";
	    }
	    for ($j=0; $j<$pad; $j++) {
		print " ";
	    }
	}
	print "\n";
    }

}

sub set_field {
    my $fld = $_[0];
    return $fld if ($fld =~ /\S/);  # if there is any non-whitespace
    return "n/a";
}

sub do_status() {
    $instance = $_[0];
    my $ln = 0;

    populate_status();
    populate_ethinfo();

    $outp[$ln++] = "Name\tLink\tDriver\t\tSpeed\tMTU\tIPv4_addr\tS-RoCE\tRMTU";

    foreach my $eth (@eth_list) {
	if ((!defined($instance) 
	     && (($linkonly == 0) || ($link_state{$eth} =~ "yes")))
	    || (defined($instance) && ($rxe_names{$eth} =~ "$instance"))) {
	    $outp[$ln] =  set_field("$eth");
	    $outp[$ln] .= "\t";
	    $outp[$ln] .= set_field("$link_state{$eth}");
	    $outp[$ln] .= "\t";
	    $outp[$ln] .= set_field("$eth_driver{$eth}");
	    $outp[$ln] .= "\t";
	    $outp[$ln] .= set_field("$link_speed{$eth}");
	    $outp[$ln] .= "\t";
	    $outp[$ln] .= set_field("$eth_mtu{$eth}");
	    $outp[$ln] .= "\t";
	    $outp[$ln] .= set_field("$ipv4_addr{$eth}");
	    $outp[$ln] .= "\t";
	    $outp[$ln] .= set_field("$rxe_names{$eth}");
	    $outp[$ln] .= "\t";
	    $outp[$ln] .= set_field("$rxe_mtu{$rxe_names{$eth}}");
	    $ln++;
	}
    }
    status_print(@outp);

    chk_module_status();
}

sub modprobe {
    my $module = $_[0];
    my $opts = $_[1];

    if ($modprobe_checked == "0") {
	$modprobe_checked = "1";
	my @lines = `modprobe -c`;
	foreach my $line (@lines) {
	    if ($line =~ /^allow_unsupported_modules  *0/) {
		$modprobe_opt = " --allow-unsupported-modules ";
		last;
	    }
	}
    }
    my $cmd = "modprobe $modprobe_opt $module $opts";
    system($cmd);
}

sub do_slow {
    @zot = ("fast_arb", "fast_req", "fast_comp", "fast_resp",);
    foreach my $file (@zot) {
	system("echo 0 > $parms/$file");
    }
}

sub do_fast {
    @zot = ("fast_arb", "fast_req", "fast_comp", "fast_resp",);
    foreach my $file (@zot) {
	system("echo 1 > $parms/$file");
    }
}

sub do_show_fast {
    @zot = ("fast_arb", "fast_req", "fast_comp", "fast_resp",);
    foreach my $file (@zot) {
	print "$file:\t" . `cat $parms/$file`;
    }
}

sub printusage {
    print "Usage:\n";
    print "rxe_cfg [options] start|stop|status|persistent|devinfo\n";
    print "rxe_cfg debug on|off|<num> "
	. "(Must be compiled in for this to work)\n";
    print "rxe_cfg crc enable|disable\n";
    print "rxe_cfg mtu [rxe0] <size> "
	. "(set ethernet mtu for one or all rxe transports)\n";
    print "rxe_cfg [-n] add eth0\n";
    print "rxe_cfg [-n] remove rxe1|eth2\n";
    print "Options:\n";
    print "-n: do not make the configuration action persistent\n";
    print "-v: print additional debug output\n";
    print "-l: in status display, show only interfaces with link up\n";
    print "-h: print this usage information\n";
    print "-p 0x8916: (start command only) - "
	. "use specified (non-default) eth_proto_id\n";
    
}
